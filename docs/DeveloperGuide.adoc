= Seller Manager Lite - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-T09-4/main

By: `Team T09-4`      Since: `Sep 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of five components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.
* <<Design-Statistics,*`Statistics`*>>: Generate statistics and charts.

Each of the five components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete-c 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts
e.g.`CommandBox`, `ResultDisplay`, `TabPanel` , `StatusBarFooter` etc.
`TabPanel` consists of `CustomerListPanel` , `OrderListPanel`, `PhoneListPanel` , `CalendarListPanel`
and `ArchivedOrderListPanel`
All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.
* Different changes in each tab or panel is controlled via the enum `UiChange`

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `SellerManagerParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a customer/phone/order/schedule).
.  The result of the command execution, a `String` message and `UiChange` enum is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `UiChange` enum in the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying the respective panels or help/statistics window.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete-c 1")` API call.

.Interactions Inside the Logic Component for the `delete-c 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCustomerCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores a `CalendarDate` object that stores date shown on the calendar panel.
* stores `Customer`, `Phone`, `Order` and `Schedule` data in a `DataBook` each.
* a `DataBook` is backed by an underlying `UniqueList` which stores subclasses of `Identifiable`
* the `Identifiable` interfaces exposes an `isSameAs` method which is used to determine if two objects have the same identity
* exposes 4 unmodifiable `ObservableList<Identifiable>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other four components.


[NOTE]
As a more OOP model, we can store a `UniqueList<Tag>` in `Seller Manager`, which `Customer` / `Phone` / `Order` / `Schedule`  can reference.
This would allow `Seller Manager` to only require one `Tag` object per unique `Tag`, instead of each object needing their own `Tag`.
An example of how such `UniqueList<Tag>` and `UniqueList<Customer>` interacts is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Customer Book data, Phone Book data, Order Book data and Schedule Book data in json format and read them
 back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Statistics Calculation and Chart generation feature
==== Implementation

This statistic calculation and chart generation feature extends `Seller Manager Lite` which allows seller to quickly
generate total statistics from their `DataBooks`, through the use of a `statistic`
module that handles this calculation.

There is three type of statistic to be calculated and only on `completed orders`:

* `Profit`
* `Cost`
* `Revenue`

It implements the following mode of operations:

* default mode with no date input: generates on all completed order total `profit` , `cost` or `revenue`
** The command enter by the user will be e.g for profit type `generate-s s/PROFIT`

* mode with date input from user: The statistic command takes in 2 `dates`, `starting date` and `ending date`
and generates the `profit`, `cost` or `revenue`  each `month` between this 2 dates.
** command entered by user will be e.g for profit type`generate-s s/PROFIT s1/YYYY.MM.DD s2/YYYY.MM.DD`

Here is the sequence of steps taken by SMLJ when it receives a `StatCommand`:

image::StatisticsCalculationAcitvityDiagram.png[]

===== Statistic Module
The statistic module exposes the calculation operations in the `Statistics` interface.
analogous to the output mode, there are 2 types of methods in this module, one that returns a
`String` and the other and `XYChart.Series<String,Number>`

* Methods that return a `String`:

** `calculateTotalProfitOnCompleted()`
** `calculateTotalRevenueOnCompleted()`
** `calculateTotalCostOnCompleted()`

* Methods that return a `XYChart.Series<String,Number>`:

** `calculateTotalProfitOnCompletedGraph()`
** `calculateTotalRevenueOnCompletedGraph()`
** `calculateTotalCostOnCompletedGraph()`

All methods were written using java8 Stream() feature. This is such that there are no loops in the code to make it
more readable and maintainable.

`org.apache.commons.math3.stat.StatUtils` library is used to calculate the raw data inside a `double[]` .
While the current `v1.4` only use `sum` to calculate the exact `profit` , `revenue` and `cost` , `v2.0` implementation
will make use of the `linear regression` / `average` methods inside the library to generate more advanced statistics.

===== Design Considerations / Alternative designs considered

Given that the number of orders in a seller database might be scaled to be very large in the future
the main focus of this feature was to *calculate statistics only when needed*.

One way that was initially considered was actually to maintain a running statistic
counter upon loading of the main app, update this counter when calculation is needed ,
and then display it. This implementation would be much easier to implement within the existing AB3 code
since it meant extending the `Model` class with a statistic model, than having the `UI` class to read from
this value *However, we dropped this due to the consideration
mentioned in the previous paragraph*

====== Decision 1:

Given that consideration, we decided that it will be the `UI` to trigger this call to `Logic` for calculation
and then display the result of that call. Thus when Statistics need to be shown, the `UI` module will query the
`Logic` for the respective data

One of the motivation for this approach was to maintain the architecture that is already in place in AB3.

Furthermore, given that this feature requires date input from the user, we will need to find a way to get `UI` to send
the data to make that query to logic. For the old AB3 implementation, `CommandResult` only contains a feedback to user
with the actual changes on data done with a call to model during `execute(model)`.


====== Decision 2:

We decided to extend this command pattern by creating a `statsPayload` object. This object will hold the user
queries for the statistic calculation (if there is any) and be bundled along with the `CommandResult` class to the
`UI` to use in its query to logic. When the Ui executes the command to logic, the `CommandResult` is returned with
this object, which the `UI` will then use to communicate to `Logic`.

The resulting change is that the `commandResult` type will have a slightly different behaviour. *All `commands` that
are not `statsCommand` will call the default constructor of the `commandResult` class, where there is  an
`Optional.empty()` in place of the `StatsPayload` * .

All `statsCommand` type will have call the constructor of `commandResult` class and pass the `StatsPayload` object in.

The key motivation behind this idea of a payload was to be able to encapsulate details about the calculation inside a
single object, passed it to the appropriate place to be "unwrapped" when needed. This unwrapping is done by the
`mainWindow` class in SMLJ and subsequently the data is passed to the  `statistic` module.


A high level view of the packages working together:

image::statsOverallClassDiagram.png[]

====== Step-by-step breakdown

Below is a more in-depth explanation at each step:


step 1: User inputs a stats command e.g `generate-s s/REVENUE d1/2018.12.13 d2/2019.11.13`.

The commandBox executes it and the `MainWindow` runs its `executeCommand(commandText)` method.

Referring to the sequence diagram below,this results in `logic.execute(commandText)` being called and
the `statsCommandParser` parses the input from the user, returning a
`Command` object

step 2: the logic then calls `command.execute(command)` (refer to the second set of arrow coming out of `LogicManager`)

When this happens, the `StatsCommand` execute triggering a call to create the new `StatsPayload`. Then this is used to
create a new `CommandResult` object and returns that to `Logic` , completing the execution of the user input command.

Shown below is a quick summary of step 1-2:

image::StatsCommandSequenceDiagram.png[]

step 3: After the logic component completes it execution and return a `CommandResult`, the `UI` will call
`performUiChanges` that handles the specific `UI` change.

This then results in the `statsPayload` class being passed to `Logic` class and subsequently the `statistics` module,
where the appropriate calculation will take place.


step 4: `Statistic Manager` calculates the date

Depending on the input, the `Statistic Manager` will calculate the value and return that, either in the form of
a `String` or a `XYChart.Series<String, Number>`

step 5: with this output from logic, `Statistic Window` will then handle the diplaying of the statistic, be it in chart
form or string form. With this the feature has finished executing! Attached below is the summary for step 3-5:

image::StatisticsCalculationUI.png[]

Limitations:

Below are some limitations that we have put in place for `v1.4` of SMLJ:

*Date range starts from 1970 onwards
** Date of year input starts from 1970 onwards. This is enough to fit our use case. Anything lower will be rejected.



=== Autocomplete feature
==== Current Implementation

This feature is visible in the UI as a dropdown menu when the user enters input into the command box.

===== How the UI works

The command box uses a custom `AutoCompleteTextField` which extends from JavaFX's `TextField`, which adds an additional listener for changes in the input text.
This listener reads the entire input text on each character change and performs comparisons with a predefined set of strings.
For all predefined strings that matches the input text, they are sorted according to their "closeness", and a maximum of 5 is displayed.

===== The underlying data structures

This feature was designed to display values that are currently in the `Model`.

For example, the input text `add-c n/` would display a list of `CustomerName` that already exists in the `Customer` `DataBook`.

In order to achieve this, the underlying data structure used is a directed `Graph` with every `Node` storing a reference to a set of values,
and a `Map<String, Node>` to represent outgoing edges. The keys of this map represent the possible prefixes for the next argument of the input text, such as `c/` or `e/`.

===== Design Considerations

* Dynamically updated: By storing references to a set of values that can be backed by `ObservableList` in the `Model`, whenever the user alters any data, it will be reflected in the displayed values.

* Supports optional arguments: By storing the possible prefixes as "edge weights", it is possible to represent an optional argument by having an edge to the `Node` containing its values, as well as an edge to the next `Node`.

* Infinite structure: By having a `TagNode` store a reference to itself, it is possible to endlessly display `t/` as a possible argument at the end of the input text,
which is consistent with the unlimited number of `Tag` a `Customer` can hold.

=== Calendar / Schedule feature
==== Implementation

We decided to incorporate a third party library, `JFXtras's Agenda`, to represent our schedules on a calendar for easy viewing by our users.

`CalendarPanel` keeps `UniqueList<Schedule>` and `UniqueList<Order>` objects as class variables. On instantiation, all the schedules in `UniqueList<Schedule>` will be converted to `Appointments` and then added to `Agenda`.
To set the display information of the `Schedule` object, we will find its `Order` in the `UniqueList<Order>` and retrieve its index.
`CalendarPanel` also keeps `CalendarDate` as a variable to set the date shown by `Agenda`.

Schedule supports a few basic commands:

* Add -- adds a new schedule into SML, command will be in this format: `add-s ORDER_INDEX cd/DATE ct/TIME v/VENUE [t/TAGS]`
* Edit -- edits an existing schedule in SML, command will be in this format: `edit-s ORDER_INDEX [cd/DATE] [ct/TIME] [v/VENUE] [t/TAGS]`
* Delete -- delete an existing schedule in SML, command will be in this format: `delete-s ORDER_INDEX`
* Schedule -- switches the week on the panel to the week containing the date entered, command will be in this format: `schedule cd/DATE`

The schedules and date the calendar panel shows is automatically updated depending on the commands executed by the users.
For example:

* If the user adds/edits/deletes a schedule -- calendar panel will display the week with the date of the schedule.
* If the user uses the switch-s command -- calendar panel will display the week with today's date.
* If the user uses the schedule command -- calendar will display the week with the date resquested by the user.

Changes to the schedules are made in the model by editing the `UniqueList<Schedule>` object.
`CalendarPanel` adds a listener to its `UniqueList<Schedule>` variable.
`CalendarPanel` listen to the changes and generates the updated list of `Schedules` into `Appointments` to add to `Agenda`.

The current date shown on the calendar panel is encapsulated in a `CalendarDate` object.
The `CalendarDate` class uses `SimpleObjectProperty` to keep track of the Calendar (date).
When any of the schedule commands are executed, the model will edit the `CalendarDate` object with the updated Calendar (date).
`CalendarPanel` adds a listener to its `CalendarDate` variable.
`CalendarPanel` listen to the changes and sets the agenda view to the new `Calendar` in `CalendarDate`.

Here is a sample of what happens when a schedule command is entered by the user:

image::ScheduleCommandSequenceDiagram.png[]

Basically, after the setCalendarDate(calendar) method in `Model` is executed, `CalendarPanel` listens to it and make the necessary changes to the agenda view by calling its setAgendaView(calendar) method.

Adding on, we will be adding an additional feature to check for clashing schedules.
In the case of a clash, users will be given a choice to allow clashing schedules, or to just change to timing to avoid the clashes.

===== Design Considerations / Alternative designs considered

We do not keep a list of `Appointment` in `CalendarPanel` as `Appointment` is only used for `Agenda` while the rest of our system uses `Schedule`.
Instead, we have decided to only convert `Schedule` into `Appointment` when needed - during the instantiation of `CalendarPanel` or when there are changes made to the `UniqueList<Schedule>`.
Not keeping a list of `Appointment` ensures that we do not keep duplicate information.

The changes to `CalendarDate` was initially done in the `CalendarPanel` itself.
So, `CommandResult` was made to have one more variable `Optional<Calendar>`.
In that case, every time a schedule command was executed, a specific `Calendar` (if any) will be placed inside the constructor while creating the `CommandResult` object.
Else, Optional.Empty() will be placed inside.

When the `MainWindow` executes the method performUiChanges(CommandResult), it will call the handleSchedule method with Calendar (from CommandResult) as an argument.
If `Optional<Calendar>` in `CommandResult` is empty, today's date and time will be used instead.
Then, `CalendarPanel` will be called in the handleSchedule method to set the agenda view.

This implementation was however changed because we thought that the date shown on the panel should be changed automatically.
Hence, we decided to use a listener instead.
`CalendarDate` is then placed in `Model` so that it can be edited right away when `Model` executes any schedule related commands.
Also, this ensures that `CommandResult` remains unchanged and kept as simple as possible.

=== Find Customer/Phone/Order feature
The find feature allows the user to find the customer/phone/order according to its data field(e.g. CustomerName, ContactNumber)
or without any data field. We wanted to implement an OR search and so long as the customer/phone/order contained the keyword
in its data, it would be shown to the user.
For simplicity's sake, we will only focus on Customer in this section.


The commands that we wanted to implement are:

* e.g. `find-c n/Alice` -- allows the user to find the customer with customer name "Alice".
* e.g. `find-c Alice` -- would allow the user to find the customer with any data field that matches "Alice".

==== Current Implementation

In order to implement the find function, we decided to create multiple predicates for each data field of Customer.
By doing this, we could do chaining of predicates by using the static `or()` provided in `java.util.Predicate` package.
Thus, we would be able to find the customer easily with the keywords given in the input.

image::CustomerPredicateClassDiagram.png[]

Below is a diagram to show you how `find-c n/Alice` runs in the program.

image::FindCustomerCommandSequenceDiagram1.png[]

Below is another diagram to show you how `find-c n/Alice e/alex` runs in the program.

image::FindCustomerCommandSequenceDiagram2.png[]

Notice that chaining takes place by creating new instances of XYZContainsKeywordsPredicates.


==== Design Considerations / Alternative designs considered

Alternative 2: The other alternative that we considered in implementing the find feature was using a single predicate.
First, we create a `FindCustomerDescriptor` that would store all the strings that were to be searched under the various data fields.
The `FindCustomerCommandParser` would store the relevant keywords in the FindCustomerDescriptor and generate a predicate,
`CustomerContainsKeywordsPredicate`, using the FindCustomerDescriptor and pass it to `FindCustomerCommand`. `FindCustomerCommand` would then be executed.

The predicate `CustomerContainsKeywordsPredicate` would do the heavy lifting by doing further parsing of the keywords
and test whether Customer contains the relevant keywords.

However, we did not do this as `CustomerContainsKeywordsPredicate` violated the Single-Responsibility Principle.
It had to do further parsing of the keywords instead of simply testing whether the Customer contains the keywords.
Also, if there was a change to the `Customer` class, it would be less intuitive to modify `CustomerContainsKeywordsPredicate`
as one would need to understand the parsing.



* **Alternative 1 (current choice):** Multiple predicates.
** Pros: Easy to implement.
** Cons: Duplicated code due to multiple predicates.
* **Alternative 2:** Single predicate.
** Pros: Less code written in total.
** Cons: Harder to maintain.

=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy to implement.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of phones, orders and customers.
* prefer desktop apps over other types
* is a one-man/two-man handphone re-seller who has multiple phones to sell.
* likes single view application.
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: Keep track of your phone, orders and customers faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |

|`* * *` |handphone seller |schedule my orders| deconflict and view the schedule of my sales meetings.

|`* *` |handphone seller |generate an invoice |give my customers the invoice.

|`* * *` |handphone seller |sort my sales statistics|find out which products are selling well.

|`* * *` |handphone seller |generate sales report |track my revenues, profits and costs.

|`* * *` |handphone seller |find my handphone model easily| not waste time searching for the handphone.

|`* * *`|handphone seller |record and track the quantity of my phones |decide when to get more phones.

|`* * *`|handphone seller |copy the email address/handphone number of my customer easily |email them/text them easily.

|`* *`| handphone seller |use a price optimization algorithm| easily price my products.

|`* *`|handphone seller | find out the market price of the phones| decide what price to set for my phones.

|`* *`|handphone seller | generate a visualisation of my meeting schedule | have a better idea of my schedule

|`* *`|handphone seller |use an auto-generated mailing list |keep track of the mails that I have to send out.

|`*`|handphone seller|organise my replies in terms of hot, medium, cold |find out how to best reply to a certain type of customer.

|`*`|handphone seller|use the trust meter system|remember which buyers cheated me before.

|`* *`|handphone seller|check notification dialog|see upcoming deadlines

|`*`|handphone seller|add images to my handphone| better visualise my products.

|`*`|handphone seller|integrate the app with an e-commerce platform|automatically update my order in my app and on the platform.

|`*`|handphone seller|view customer profile|see the number of transactions and the types of goods they bought.

|`* *`|handphone seller|undo and redo|correct my mistakes.

|`* *`|handphone seller|import my sales data from csv file|save the trouble of manual importing.

|`* * *`|handphone seller|add, edit and delete the phones that I have|update when there is a need to.

|`* * *`|handphone seller|create a new order|schedule the order.

|`* * *`|handphone seller|cancel order|reflect the changes made by customer.

|`* * *`|handphone seller|sort statistics by brand|find out which brand is the most popular.

|`* * *`|handphone seller|generate statistics for total sales or total profit per month| find out how much I earn.

|`* * *`|handphone seller|find the details of the order that I want easily| save time searching for an order.

|`* * *`|handphone seller|delete a phone that I am no longer selling| get rid of it on the database.

|`*`|handphone seller|track my customer age|know the suitability of my product.

|`*`|handphone seller|use an in-built messenger to communicate with my customer| talk to them without switching to another application.
|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `SML` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete customer (UC01)

*MSS*

1.  User requests to list customer
2.  SML shows a list of customers
3.  User requests to delete a specific customer in the list
4.  SML deletes the customer
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. SML shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add new phone (UC02)

*MSS*

1. Actor input phone name and quantity.
2. System adds phone to the list of phones.
3. System shows the new list of phones.

*Extensions*

[none]
* 1a. Actor inputs wrong date format.
+
Use case ends.
[none]
** 1a1. SML requests for correct data.
+
Use case resumes at step 1.

[discrete]
=== Use case: Check quantity of phone (UC03)

*MSS*

1. Actor requests to check stock of a phone.
2. System displays the stock status for a phone.

*Extensions*

[none]
* 1a. System is unable to find the phone as it does not exist.
+
Use case ends.
[none]
** 1a1. System shows error message that phone does not exist.
+
Use case resumes at step 1.

[discrete]
=== Use case: Confirm order (UC04)

*MSS*

1. Actor requests to check stock of a phone (UC03).
2. Actor add order to the system. System displays the new order list.
3. Actor schedule order. (UC05)
4. Actor mark order as completed. System displays completed order message.


*Extensions*

[none]
* 2a. System is unable to add as command is missing fields.
+
Use case ends.
[none]
** 2a1. System shows error message that command is missing fields.
+
Use case resumes at step 2.

[discrete]
=== Use case: Actor schedule order (UC05)

*MSS*

1. Actor adds order to schedule by some identifier.
2. System check for conflict in timings.
3. System displays the scheduled order.

*Extensions*

[none]
* 2a. System finds out that there is a conflict in timing for 2 or more orders.

+
Use case ends.
[none]
** 2a1. System displays the 2 or more orders that have the same schedule timing.
+
Use case resumes at step 2.

[discrete]
=== Use case: Actor input data via .csv file (UC06)

*MSS*

1. Actor requests to import .csv file.
2. System loads file into memory.
3. System reads the file and saves it.
4. System displays the updated data.

*Extensions*

[none]
* 1a. System finds that no file is found.
* 1b. System finds that there is an error with the formatting.

+
Use case ends.
[none]
** 1a1. System displays error message and does not add new data from the file.
+
Use case resumes at step 1.
[none]
** 1b1. System displays error message and does not add the new data from the file.
+
Use case resumes at step 1.



_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Single User for each session
.  No internet required
.  Quality and helpful information/feedback upon user action
.  System should ideally respond within 5 seconds
.  System allows for wrong input from user and recovers from erroneous input
.  App can be downloaded and run via a jar file

_ {More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[order]] Order::
A order consisting of customer and phone

[[Phone]] Phone::
Any mobile device being sold by seller

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
